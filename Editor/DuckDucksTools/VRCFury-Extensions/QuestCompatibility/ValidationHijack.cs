using UnityEditor;
using UnityEngine;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System;
using VF.Model;
using VF.Model.Feature;

using DuckDuckReflectionBuggery;

// An important note on readonly fields
// if you set a readonly field (via reflection) outside of 
// a global constructor you corrupt memory and eventually crash unity
// why does this happen? who knows! we're just going to have to live with it

namespace VF {
    /** 
     * This class hijacks the avatar validation system to permit the upload
     * of avatars that are not quest compatible until after VRCFury has
     * finished processing the avatar.
     */ 
    [InitializeOnLoad]
    public class ValidationHijack {
        // This replaces the whitelist used by the validation system
        // It is dynamically updated as the shaders on the avatar change
        // It is readonly as the field in the validation system is readonly
        // and cannot be modified outside of global constructors without
        // crashing Unity.
        // 1024 is a number that I picked that should be large enough to
        // accomodate all of the shaders that are used on an avatar.
        // (hopefully not foreshadowing problems)
        //TODO: can the issues just be deleted from the error list instead?
        private static readonly string[] shaderWhitelist = new string[1024];

        // The default whitelist is copied here at startup so that it can be
        // copied to the shader whitelist when the quest compatibility feature
        // is disabled.
        private static string[] defaultShaderWhitelist;

        // This is a reference to the currently selected avatar in the builder
        // menu of the SDK. The type is VRC.SDK3.Avatars.Components.VRCAvatarDescriptor
        // it is a static field on the AvatarBuilder class.
        private static FieldInfo avatarBuilderSelectedAvatarField;

        // This is a reference to the list of allowed components generated by
        // the SDK on first validation. It is static but not readonly, so it
        // can be changed to a dynamically generated array as needed.
        // Its type is string[]
        // It is a static field on the AvatarValidation class.
        private static FieldInfo validationAllowedComponentsField;

        // This is a cache of component types that are permitted on an avatar.
        // The SDK uses this cache to speed up validation, but it is not
        // exposed to the outside world. When the list of allowed components
        // is changed, this cache must be cleared so that the SDK will
        // regenerate it. It is a private static readonly field on the
        // ValidationUtils class.
        // Similarly to the shaderWhitelist field, it cannot be modified
        // outside of a global constructor without crashing Unity.
        private static readonly Dictionary<string, HashSet<Type>> whitelistCache = new Dictionary<string, HashSet<Type>>();

        // shorthand function
        private static Type GetType(string name) {
            return ReflectionUtils.GetTypeFromAnyAssembly(name);
        }

        // Other classes can use this to check if the validation hijack is
        // set up properly. The only case this is true is if the setup
        // function throws an exception.
        public static bool validationHijackFailed = false;

        // This function is called from the global constructor to set up the
        // validation hijack. It sets the shader whitelist to the static array
        // defined above, and sets several fields references to access private
        // fields in the SDK.
        public static void SetupValidationHijack() {
            // if any of these fail, the SDK has changed and the hijack will not work
            var avatarBuilder = GetType("VRC.SDKBase.Editor.VRCSdkControlPanelAvatarBuilder");
            avatarBuilderSelectedAvatarField = avatarBuilder.GetField("_selectedAvatar", BindingFlags.Static | BindingFlags.NonPublic);

            var validation = GetType("VRC.SDKBase.Validation.AvatarValidation");
            var shaderWhitelistField = validation.GetField("ShaderWhiteList", BindingFlags.Static | BindingFlags.Public);
            defaultShaderWhitelist = shaderWhitelistField.GetValue(null) as string[];
            shaderWhitelistField.SetValue(null, shaderWhitelist);

            var validation3 = GetType("VRC.SDK3.Validation.AvatarValidation");
            validationAllowedComponentsField = validation3.GetField("CombinedComponentTypeWhiteList", BindingFlags.Static | BindingFlags.NonPublic);
            validationAllowedComponentsField.GetValue(null); // throws exception on purpose if null

            var validationUtils = GetType("VRC.SDKBase.Validation.ValidationUtils");
            var whitelistCacheField = validationUtils.GetField("_whitelistCache", BindingFlags.Static | BindingFlags.NonPublic);
            whitelistCacheField.SetValue(null, whitelistCache);
        }

        // Global constructor. This is called when the assembly is loaded.
        static ValidationHijack() {
            try {
                SetupValidationHijack();
                EditorApplication.update += UpdateValidationWhitelists;
            } catch (Exception e) {
                validationHijackFailed = true;
                Debug.LogError("Failed to set up validation hijack: " + e);
            }
        }

        // Overwrites the shader whitelist with the provided list.
        // Note: this updates the array in-place.
        public static void SetShaderWhitelist(IEnumerable<string> whitelist) {
            shaderWhitelist.Initialize();
            Array.Copy(whitelist.ToArray(), shaderWhitelist, whitelist.Count());
        }

        // Enables or disables the extended component validation.
        // When restricted, the component whitelist is set to the default
        // whitelist provided by the SDK. When not restricted, the component
        // whitelist is set to include all components that are allowed on
        // desktop avatars, plus the components that are allowed on both.
        public static void SetComponentValidation(bool restricted)  {
            if (!restricted) {
                // This is normally done by the SDK.
                Type validation = GetType("VRC.SDKBase.Validation.AvatarValidation");

                string[] allowedComponentsCommon = validation.GetField("ComponentTypeWhiteListCommon", BindingFlags.Static | BindingFlags.Public).GetValue(null) as string[];
                string[] allowedComponentsSdk3 = validation.GetField("ComponentTypeWhiteListSdk3", BindingFlags.Static | BindingFlags.Public).GetValue(null) as string[];
                var allowedComponents = new List<string>();
                allowedComponents.AddRange(allowedComponentsCommon);
                allowedComponents.AddRange(allowedComponentsSdk3);
                // Except for this part.
                allowedComponents.AddRange(VF.Feature.QuestCompatibilityBuilder.disallowedComponents);
                validationAllowedComponentsField?.SetValue(null, allowedComponents.ToArray());
            } else {
                // When this value is null, the SDK will generate the default whitelist.
                // This will include the components added by VRCFury.
                validationAllowedComponentsField?.SetValue(null, null);
            }

            whitelistCache?.Clear();
        }

        // Grabs the currently selected avatar from the SDK builder.
        public static GameObject GetSelectedAvatar() {
            var aviDesc = avatarBuilderSelectedAvatarField?.GetValue(null) as VRC.SDKBase.VRC_AvatarDescriptor;
            // no null-conditional for Unity objects
            return (aviDesc != null) ? aviDesc.gameObject : null;
        }

        // Returns a sorted list of shader names used on the provided avatar.
        private static List<string> GetShadersUsedOnAvatar(GameObject avatar) {
            return avatar.GetComponentsInChildren<Renderer>(true)
                .SelectMany(r => r.sharedMaterials)
                .Where(m => m != null)
                .Select(m => m.shader.name)
                .Distinct()
                .OrderBy(s => s)
                .ToList();
            // god I love LINQ
        }

        // stores the list of shaders seen during the last updateshaderwhitelist call
        private static List<string> lastSeenShadersOnAvatar = new List<string>();

        // Updates the shader whitelist if the shaders on the selected avatar
        // have changed.
        private static void UpdateShaderWhitelistIfRequired() {
            var avatar = GetSelectedAvatar();
            if (avatar == null) {
                return;
            }

            // get the list of VRCFury features on the avatar
            var furyFeatures = avatar.GetComponents<VRCFury>().SelectMany(f => f.config.features);
            List<string> shadersOnAvatar = null;

            if (furyFeatures == null || !furyFeatures.Any(f => f is QuestCompatibility)) {
                // if the avatar doesn't have the quest feature, use the default whitelist
                shadersOnAvatar = defaultShaderWhitelist.ToList();
            } else {
                // if the avatar has the quest feature, use the list of shaders on the avatar
                shadersOnAvatar = GetShadersUsedOnAvatar(avatar);
            }

            // only if the list of shaders has changed...
            if (!shadersOnAvatar.SequenceEqual(lastSeenShadersOnAvatar)) {
                lastSeenShadersOnAvatar = shadersOnAvatar;
                // ...update the shader whitelist...
                SetShaderWhitelist(shadersOnAvatar);
                // ...and trigger revalidation
                ControlPanelResetIssues();
            }
        }

        // stores the last seen value of the quest feature presence
        private static bool lastSeenAvatarHadQuestFeature = false;

        // Updates the component whitelist if the quest feature has been added
        // or removed from the selected avatar.
        private static void UpdateAllowedComponentsListIfRequired() {
            var avatar = GetSelectedAvatar();
            if (avatar == null) {
                return;
            }

            var furyFeatures = avatar.GetComponents<VRCFury>().SelectMany(f =>  f.config.features);
            bool hasQuestFeature = (furyFeatures != null && furyFeatures.Any(f => f is QuestCompatibility));

            // only if the value has changed...
            if (hasQuestFeature != lastSeenAvatarHadQuestFeature) {
                lastSeenAvatarHadQuestFeature = hasQuestFeature;
                // ...update the component whitelist...
                SetComponentValidation(restricted: !hasQuestFeature);
                // ...and trigger revalidation
                ControlPanelResetIssues();
            }
        }

        // Equivalent to EditorWindow.GetWindow<VRCSdkControlPanel>()?.ResetIssues();
        // without the assembly reference.
        // Resets the list of issues in the SDK builder so that it will be regenerated.
        private static void ControlPanelResetIssues() {
            Type controlPanel = GetType("VRCSdkControlPanel");
            var resetIssuesMethod = controlPanel.GetMethod("ResetIssues", BindingFlags.Instance | BindingFlags.Public);

            var window = controlPanel.GetField("window", BindingFlags.Static | BindingFlags.Public).GetValue(null);
            if (window == null) return;

            resetIssuesMethod.Invoke(window, null);
        }

        private static readonly string[] physboneLimitsFilterText = new string[] {
            "All PhysBone components will be removed at runtime.",
            "All PhysBone colliders will be removed at runtime.",
            "All VRCContact components will be removed at runtime.",
        };

        private static void CheckAndRemovePhysboneLimitsErrors() {
            //Type controlPanel = GetType("VRCSdkControlPanel");
            //Type issue = GetType("VRCSdkControlPanel+Issue");


            //var window = controlPanel.GetField("window", BindingFlags.Static | BindingFlags.Public).GetValue(null);
            var window = GetType("VRCSdkControlPanel").R_GetField("window");
            if (window == null) return;

            //Dictionary<Object, List<Issue>> GUIErrors;
            // can't work with dynamic objects because we don't have visibility into the assembly (? stackoverflow says so)
            // casting to Dictionary<Object, List<object>> doesn't work because idk
            // so we have to use reflection to deal with the dictionary (and the list inside it) (most cursed option)
            // send help

            //Dictionary<Object, List<Issue>> GUIErrors = GetField(window, "GUIErrors") as Dictionary<Object, List<Issue>>;
            var GUIErrors = window.R_GetField("GUIErrors");

            // if (GUIErrors.Count == 0) return;
            if ((int) GUIErrors.R_GetProp("Count") == 0) return;

            GameObject avi = GetSelectedAvatar();
            if (avi == null) return;

            bool hasCompatFeature = avi.GetComponents<VRCFury>().Any(f => f.config.features.Any(feat => feat is QuestCompatibility));
            if (!hasCompatFeature) return;

            var dictKey = avi.GetComponent<VRC.SDKBase.VRC_AvatarDescriptor>();
            
            // if (!GUIErrors.ContainsKey(dictKey)) return;
            if (!(bool)GUIErrors.R_Invoke("ContainsKey", dictKey)) return;

            //List<Issue> issuesList = GUIErrors[dictKey];
            var issuesList = GUIErrors.R_GetProp("Item", dictKey);

            // issuesList.RemoveAll(issue => physboneLimitsFilterText.Any(text => issue.issueText.Contains(text)));
            Predicate<object> filter = (o) => {
                string text = o.R_GetField("issueText") as string;
                return physboneLimitsFilterText.Any(t => text.Contains(t));
            };
            issuesList.R_Invoke("RemoveAll", filter);

            // if (issuesList.Count == 0) GUIErrors.Remove(dictKey);
            int remainingCount = (int) issuesList.R_GetProp("Count");
            if (remainingCount == 0) GUIErrors.R_Invoke("Remove", dictKey);

        }

        // Called every frame. Updates the shader and component whitelists if
        // required. Only runs if the active build target is Android.
        public static void UpdateValidationWhitelists() {
            if (EditorUserBuildSettings.activeBuildTarget != BuildTarget.Android) {
                return;
            }
            UpdateShaderWhitelistIfRequired();
            UpdateAllowedComponentsListIfRequired();
            CheckAndRemovePhysboneLimitsErrors();
        }
    }
}

// horrible cludges to make reflection easier
// keep this namespace away from children and small animals
namespace DuckDuckReflectionBuggery {
    // prepend each method with R_ to make the usage clearer
    public static class ReflectionExtensions {
        // binding flags for instance members and static members respectively
        private static readonly BindingFlags instanceBF = BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic;
        private static readonly BindingFlags staticBF = BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic;

        // retrieves a field from an object
        public static object R_GetField(this object obj, string name) {
            return obj.GetType().GetField(name, instanceBF).GetValue(obj);
        }

        // retrieves a property from an object (ie. a field with a getter)
        public static object R_GetProp(this object obj, string name) {
            return obj.GetType().GetProperty(name, instanceBF).GetValue(obj);
        }

        // retrieves a property from an object with argument (only used for indexers)
        public static object R_GetProp(this object obj, string name, params object[] param) {
            return obj.GetType().GetProperty(name, instanceBF).GetValue(obj, param);
        }

        // invokes a method on an object, pretty straightforward
        public static object R_Invoke(this object obj, string name, params object[] args) {
            Type t = obj.GetType();
            MethodInfo m;
            if (args == null) {
                m = t.GetMethod(name, instanceBF);
            } else {
                m = t.GetMethod(name, instanceBF, null, args.Select(a => a.GetType()).ToArray(), null);
            }
            return m.Invoke(obj, args);
        }

        // R_GetField but for static fields
        public static object R_GetField(this Type t, string name) {
            return t.GetField(name, staticBF).GetValue(null);
        }

        // R_GetProp but for static properties
        public static object R_GetProp(this Type t, string name, params object[] param) {
            return t.GetProperty(name, staticBF).GetValue(null, param);
        }
    }
}